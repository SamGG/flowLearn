#' Computes a euclidean distance matrix for two given densities.
#'
#' @param x First density of length n.
#' @param y Second density of length m.
#'
#' @return A n-by-m matrix with pairwise euclidean distances.
dtwDistanceMatrix <- function(x, y)
{
    proxy::dist(x, y)
}

#' Computes a distance matrix for derivative DTW, given two densities.
#'
#' @param x First density of length n.
#' @param y Second density of length n.
#'
#' @return A n-by-n matrix with pairwise derivative distances.
derivativeDtwDistanceMatrix <- function(x, y)
{
    if(length(x) != length(y))
    {
        stop('Densities x and y must be of same length.')
    }

    difX <- sapply(2:(length(x)-1), function(i) (x[i] - x[i-1]) + ((x[i+1] - x[i-1]) / 2) / 2)
    difX <- c(difX[1], difX, difX[length(x)-2])
    difY <- sapply(2:(length(x)-1), function(i) (y[i] - y[i-1]) + ((y[i+1] - y[i-1]) / 2) / 2)
    difY <- c(difY[1], difY, difY[length(x)-2])                

    proxy::dist(difX, difY)
}

weighDtwDistances <- function(m, g = 0.025)
#' Given a DTW distance matrix, weighs it according to Weighted DTW.
#'
#' @param m Distance matrix, i.e. as generated by dtwDistanceMatrix() or derivativeDtwDistanceMatrix().
#' @param g Steepness of the underlying sigmoid function.
#'
#' @return A matrix of the same size of the input matrix, containing weighted elements.
{    
    n <- nrow(m)
    w <- 1 / (1 + exp(-g * (as.matrix(proxy::dist(1:n)) - n / 2)))
    w * m
}

#' Global proxy function which modularizes the parameters for DTW 
#'
#' This function exists to ensure consistent use throughout flowLearn. 
#' To Change DTW parameters, change this function.
#' Calls dtw::dtw with parameters suitable for flowLean.
#'
#' @param a First density of length n.
#' @param b Second density of length n.
#'
#' @return A dtw object as returned by dtw::dtw.
#'
#' @export
dtwMain <- function(a, b, ...)
{
    # dtw(a, b, ...)

    ddtw <- dtw::dtw(derivativeDtwDistanceMatrix(a, b), step.pattern = dtw::typeIds, ...)

    # When using derivative DTW, we set the original densities as query and
    # reference for easier visualization
    ddtw$query <- a
    ddtw$reference <- b
    ddtw
}

#' Computes DTW distance matrices for channel A and B, respectively.
#'
#' Each matrix is of size nxn where n is the number of samples.
#' This implementation is parallelized. Only the upper triangle matrix is computed and then mirrored.
#'
#' @param tr A LearningSet object.
#' @param cl A compute cluster as obtained by parallel::makeCluster()
#'
#' @return A list with keys dA and dB indicating the distance matrices for channel A and B.
dtwDistanceMatrices <- function(tr, cl)
{

    n <- length(tr@samples)

    # channel A

    m <- parallel::parSapply(cl, 2:n, # start at 2 for upper triangle only
        function(i.1) 
        {
            sapply(1:(i.1-1), function(i.2) dtwMain(tr@densYchanA[i.1,], tr@densYchanA[i.2,], distance.only = T)$distance)
        })

    dA <- matrix(0, n, n)
    dA[lower.tri(dA, diag=FALSE)] <- unlist(m)
    dA <- dA + t(dA)

    # channel B

    m <- parallel::parSapply(cl, 2:n, # start at 2 for upper triangle only
        function(i.1) 
        {
            sapply(1:(i.1-1), function(i.2) dtwMain(tr@densYchanB[i.1,], tr@densYchanB[i.2,], distance.only = T)$distance)
        })

    dB <- matrix(0, n, n)
    dB[lower.tri(dB, diag=FALSE)] <- unlist(m)
    dB <- dB + t(dB)

    list(dA = dA, dB = dB)
}