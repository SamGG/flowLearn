dtwDistanceMatrix <- function(x, y)
# Computes a euclidean distance matrix for two given densities.
#
# Args:
#   x: First density of length n.
#   y: Second density of length m.
#
# Returns:
#   A n-by-m matrix with pairwise euclidean distances.
{
    dist(x, y)
}

derivativeDtwDistanceMatrix <- function(x, y)
# Computes a distance matrix for derivative DTW, given two densities.
#
# Args:
#   x: First density of length n.
#   y: Second density of length n.
#
# Returns:
#   A n-by-n matrix with pairwise derivative distances.    
{
    if(length(x) != length(y))
    {
        stop('Densities x and y must be of same length.')
    }

    difX <- sapply(2:(length(x)-1), function(i) (x[i] - x[i-1]) + ((x[i+1] - x[i-1]) / 2) / 2)
    difX <- c(difX[1], difX, difX[length(x)-2])
    difY <- sapply(2:(length(x)-1), function(i) (y[i] - y[i-1]) + ((y[i+1] - y[i-1]) / 2) / 2)
    difY <- c(difY[1], difY, difY[length(x)-2])                
    dist(difX, difY)
}

weighDtwDistances <- function(m, g = 0.025)
# Given a DTW distance matrix, weighs it according to Weighted DTW.
#
# Args:
#   m: Distance matrix, i.e. as generated by dtwDistanceMatrix() or derivativeDtwDistanceMatrix().
#   g: Steepness of the underlying sigmoid function.
#
# Returns:
#   A matrix of the same size of the input matrix, containing weighted elements.
{    
    n <- nrow(m)
    w <- 1 / (1 + exp(-g * (as.matrix(dist(1:n)) - n / 2)))
    w * m
}

#' @export
dtwMain <- function(a, b, ...)
# There is a global proxy function which modularizes the parameters for DTW to
# ensure consistent use throughout flowLearn. To Change DTW parameters, change
# this function.
# Calls dtw::dtw with parameters suitable for flowLean.
#
# Args:
#   a: First density of length n.
#   b: Second density of length n.
#
# Returns:
#   An dtw object as returned by dtw::dtw.
{
    # dtw(a, b, ...)

    ddtw <- dtw(derivativeDtwDistanceMatrix(a, b), step.pattern = typeIds, ...)

    # When using derivative DTW, we set the original densities as query and
    # reference for easier visualization
    ddtw$query <- a
    ddtw$reference <- b
    ddtw
}

dtwDistanceMatrices <- function(tr, cl)
# Computes DTW distance matrices for channel A and B, respectively.
# Each matrix is of size nxn where n is the number of samples.
# This implementation is parallelized. Only the upper triangle matrix is computed and then mirrored.
#
# Args:
#   tr: A LearningSet object.
#   cl: A compute cluster as obtained by parallel::makeCluster()
#
# Returns:
#   A list with keys dA and dB indicating the distance matrices for channel A and B.
{

    n <- length(tr@samples)

    # channel A

    m <- parSapply(cl, 2:n, # start at 2 for upper triangle only
        function(i.1) 
        {
            sapply(1:(i.1-1), function(i.2) dtwMain(tr@densYchanA[i.1,], tr@densYchanA[i.2,], distance.only = T)$distance)
        })

    dA <- matrix(0, n, n)
    dA[lower.tri(dA, diag=FALSE)] <- unlist(m)
    dA <- dA + t(dA)

    # channel B

    m <- parSapply(cl, 2:n, # start at 2 for upper triangle only
        function(i.1) 
        {
            sapply(1:(i.1-1), function(i.2) dtwMain(tr@densYchanB[i.1,], tr@densYchanB[i.2,], distance.only = T)$distance)
        })

    dB <- matrix(0, n, n)
    dB[lower.tri(dB, diag=FALSE)] <- unlist(m)
    dB <- dB + t(dB)

    list(dA = dA, dB = dB)
}