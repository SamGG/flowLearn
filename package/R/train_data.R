#' The TrainingGate class is an intermediate representation to which training data is converted. 
#'
#' Here, training data might come in several forms (e.g.
#' manual gates, flowDensity gates) and special conversion scripts are required
#' to generate objects of this class. These objects are later used for training
#' and testing.
#'
#' @slot parentName Name of the parent population
#' @slot channelA Index of first channel in an expression matrix
#' @slot channelB Index of second channel in an expression matrix
#' @slot thresholdALow Lower threshold of channel A (NaN if not existent)
#' @slot thresholdAHigh Upper threshold of channel A (NaN if not existent)
#' @slot thresholdBLow Lower threshold of channel B (NaN if not existent)
#' @slot thresholdBHigh Upper threshold of channel B (NaN if not existent)
#' @slot negate TRUE if the gated population is the inverse of the gate set by the thresholds
#' @slot gateAssignments Logical vector of length = numer of cells in the parent population, indicating whether  |a gated cell is inside or outside the target population
#' @slot densitiesA List of density objects for channel A as generated by flowLearn's estimateDensity function, for different numbers of features.
#' @slot densitiesB List of density objects for channel B as generated by flowLearn's estimateDensity  function, for different numbers of features.
#'
#' @export
TrainingGate <- setClass("TrainingGate",
                         slots = c(
                                   parentName = "character",
                                   channelA = "numeric",
                                   channelB = "numeric",
                                   thresholdALow = "numeric",
                                   thresholdAHigh = "numeric",
                                   thresholdBLow = "numeric",
                                   thresholdBHigh = "numeric",
                                   negate = "logical",
                                   gateAssignments = "logical",
                                   densitiesA = "list",
                                   densitiesB = "list"
                                   )
                         )

#' The LearningSet class contains similar entries as TrainingGate, 
#'
#' However the latter might contain densities of multiple granularity and evaluation
#' information such as true gate assignments. The class LearningSet is a more
#' condensed version containing less information, making it easier to load it as
#' an intermediate object during evaluation. 
#'
#' @slot densXchanA Matrix of density x values for channel A for each sample / row
#' @slot densXchanB Matrix of density x values for channel B for each sample / row
#' @slot densYchanA Matrix of density estimations for channel A for each sample / row
#' @slot densYchanB Matrix of density estimations for channel B for each sample / row
#' @slot threshA Two-element vector containing lower and upper threshold or NaN for channel A
#' @slot threshB Two-element vector containing lower and upper threshold or NaN for channel B
#' @slot samples Names of samples
#'
#' @export
LearningSet <- setClass("LearningSet",
                         slots = c(
                                   densXchanA = "matrix",
                                   densXchanB = "matrix",
                                   densYchanA = "matrix",
                                   densYchanB = "matrix",
                                   threshA = "matrix",
                                   threshB = "matrix",
                                   samples = "list"
                                   )
                         )

#' Loads training data for one population.
#'
#' @param folder Folder containing the data.
#' @param population The population to load.
#' @param numFeatures Number of features to use.
#'
#' @return A LearningSet object that contains the requested data.
readTrainFiles <- function(folder, population, numFeatures = 512)
{
    files <- list.files(path = folder, full.names = T, recursive = F, pattern = '*.rds')
    filesNames <- list.files(path = folder, full.names = F, recursive = F, pattern = '*.rds')

    densXchanA <- matrix(NaN, ncol = numFeatures, nrow = length(files))
    densYchanA <- matrix(NaN, ncol = numFeatures, nrow = length(files))
    densXchanB <- matrix(NaN, ncol = numFeatures, nrow = length(files))
    densYchanB <- matrix(NaN, ncol = numFeatures, nrow = length(files))
    threshA <- matrix(NaN, ncol = 2, nrow = length(files))
    threshB <- matrix(NaN, ncol = 2, nrow = length(files))

    samples <- list()

    i <- 1
    for (f in files)
    {
        s <- readRDS(f)
        samples[[i]] <- filesNames[[i]]
        densXchanA[i, ] <- s[[population]]@densitiesA[[as.character(numFeatures)]]$x
        densYchanA[i, ] <- s[[population]]@densitiesA[[as.character(numFeatures)]]$y
        densXchanB[i, ] <- s[[population]]@densitiesB[[as.character(numFeatures)]]$x
        densYchanB[i, ] <- s[[population]]@densitiesB[[as.character(numFeatures)]]$y
        threshA[i, ] <- c(s[[population]]@thresholdALow, s[[population]]@thresholdAHigh)
        threshB[i, ] <- c(s[[population]]@thresholdBLow, s[[population]]@thresholdBHigh)

        i <- i + 1
    }

    LearningSet(        
        densXchanA = densXchanA,
        densYchanA = densYchanA,
        densXchanB = densXchanB,
        densYchanB = densYchanB,
        threshA = threshA,
        threshB = threshB,
        samples = samples
    )
}

#' Permutes a LearningSet object (as loaded by readTrainFiles).
#'
#' @param tr The LearningSet object.
#' @param perm The permutation to use (use the sample function).
#' @param seed Random seed to use (ignored when perm is given).
#' @param subsampleRatio Only return this proportion of the given data, i.e. for bootstrapping. Ignored if perm is given
#'
#' @return A LearningSet object that was permuted by the given parameters.
permTrainFiles <- function(tr, perm = NaN, seed = NaN, subsampleRatio = NaN)
{

    n <- length(tr@samples)
    
    if (is.nan(perm[[1]]))
    {
        if (!is.nan(seed))
        {
            set.seed(seed)
        }

        perm <- sample(n)

        if (!is.nan(subsampleRatio))
        {
            perm <- perm[1:round(subsampleRatio * n)]
        }
    }

    tr@densXchanA <- tr@densXchanA[perm, ]
    tr@densYchanA <- tr@densYchanA[perm, ]
    tr@densXchanB <- tr@densXchanB[perm, ]
    tr@densYchanB <- tr@densYchanB[perm, ]
    tr@threshA <- tr@threshA[perm, ]
    tr@threshB <- tr@threshB[perm, ]
    tr@samples <- tr@samples[perm]

    tr
}