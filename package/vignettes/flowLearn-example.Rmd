---
title: "flowLearn example"
author: "Markus Lux"
date: "`r Sys.Date()`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{flowLearn example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

flowLearn can predict flow cytometry gating channel thresholds based on only
density information and (very) few manual expert gates provided. To achieve
that, it compares and aligns densities such that thresholds can be transferred
from one sample to another.

This vignette introduces flowLearn by a small example.

## Data structures

flowLearn provides the data structure `LearningSet` to use for prediction.
This structure contains densities for both channels (in flowLearn denoted by
`channel A` and `channel B`) as well as true training thresholds. In order to
use flowLearn, gating data has to be converted into this data structure.
Additionally, a matrix of alignment distances has to be given. It can be
computed using the `dtwDistanceMatrices` function.

We provide predefined example `LearningSet` and alignment distance matrices in
objects 

- `flowLearnSampleTrainingGates`,
- `flowLearnSampleAlignmentDistancesChannelA`,
- `flowLearnSampleAlignmentDistancesChannelB`, 

respectively.

We are going to use this data in our vignette:

```{r}
library(flowLearn)

tr <- flowLearnSampleTrainingGates
dA <- flowLearnSampleAlignmentDistancesChannelA
dB <- flowLearnSampleAlignmentDistancesChannelB
```

Let's inspect the data:

```{r}
print(slotNames(tr))
print(paste0('Number of samples = ', length(tr@samples)))
print(paste0('Dimension of matrix dA = ', nrow(dA)))
print(paste0('Dimension of matrix dB = ', nrow(dB)))
```

As you can see, the variable `tr` contains `x` and `y` density information for
both channels A and B, as well as thresholds for those channels and a list of
samples. We have 10 samples for which we have quadratic alignment distance
matrices for both channels.

Learn more about the `LearningSet` data structure in the package help:
`?LearningSet`.

## Predicting thresholds

Now, our task is to predict thresholds by picking a prototype for each
channel, and transferring thresholds using alignments to the closest
prototypes. This can be done using only few commands.

For convenience, we manually pick the first two samples as prototypes:

```{r}
trainIdxA <- c(1, 2)
trainIdxB <- c(9, 10)
```

We have to build a `selectedPrototypes` structure, which contains information
about which indices are used for training and testing:

```{r}
selectedPrototypes <- selectFixedPrototypes(tr, dA, dB, trainIdxA, trainIdxB)
print(selectedPrototypes)
```

Here, `testIdx` is the list of indices used for testing (not being
prototypes), `prototypesA` and `prototypesB` containing indices of the nearest
prototypes for each test sample. As you can see, for channel A both specified
prototypes are used, whereas for channel B only the prototype with `index =
10` is used. The other specified prototype with `index = 9` apparently is not
representative enough in terms of alignment distances.

Instead of using `selectFixedPrototypes`, one could also use
`selectPrototypes` to use random prototypes. In the near future, flowLearn
will be able to select prototypes based on their alignment suitability.

Now, we have everything set up to predict thresholds of our test samples:

```{r}
predictedThresholds <- predictThresholds(tr, selectedPrototypes)
```

We can visualize those thresholds for an exemplary index using flowLearn's
`plotDensThresh` function for both channels. The red lines shows the true
ground-truth threshold and the blue line shows the predicted threshold. Both
thresholds match up very well:

```{r, out.width = '200px', height = '100px', fig.align = 'center'}
i <- 6
idx <- selectedPrototypes$testIdx[i]

# channel A
plotDensThresh(tr@densXchanA[idx,], tr@densYchanA[idx,], 
               tr@threshA[idx,], predictedThresholds$threshA[i,])

# channel B
plotDensThresh(tr@densXchanB[idx,], tr@densYchanB[idx,], 
               tr@threshB[idx,], predictedThresholds$threshB[1,])
```

